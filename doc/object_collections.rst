Objects Collections
===================

Overview
--------

This document describes the interface interacting with a collection of objects (as deinfed in :ref:`typesystem`) of a specific system.      

Attaching objects types to system
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Interaction with object collections is done using :class:`The Collection Type Binder <.TypeBinder>` and not directly with the object type classmethods.
Binders are grouped in :class:`.CollectionBinderContainer`. There are 2 main collections:

 1. system.objects
 2. system.components  

Adding binder is done using :func:`.CollectionBinderContainer.install`  and is being done once at system initialization. 

It also exposes methods for getting the installed types:


.. code-block:: python

    >>> objects = CollectionBinderContainer(system)
    >>> class Filesystem(SystemObject):
    ...     pass
    >>> objects.install(Filesystem)

Querying object binders:

.. code-block:: python

   >>> objects.get_types()
   [<class Filesystem>]
   >>> objects.get_type("Filesystem")
   <class Filesystem>
   >>> objects.get_type_names()
   ["Filsystem"]
   >>> objects.Filesystem
   <Filesystem binder for ...>
   >>> objects["Filesystem"]
   <Filesystem binder for ...>
   >>> objects.get_binders()
   [<Filesystem binder for ...>]



.. autoclass:: infinipy2.core.binder_container.CollectionBinderContainer
   :members:
   
   .. automethod:: __getitem__(classname)

Events binder is attached directly to the :class:`.System` object.

Objects Collection Type Binder
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

A :class:`Collection Type Binder <.TypeBinder>` is an entry point for interacting with a specific collection or it's members on a specific system.
Each system object type has it's own binder, which binds relevant class methods (:func:`SystemObjec.find` for example) 
In addition it may add methods which are relevant to a specific collection (for example Node.get_master())

For example, filesystem creation is done using the system.objects.Filesystem.create() method and not directly through the Filesystem class.

Each <add link to system object docs> type defines which binder should be used.
Binders may be attached to a system via a binder container (components, user objects) or directly (events)
The bounded methods and the binder class are defined *_BINDER_CLASS* and the bounded methods are defined in *_BOUNDED_METHODS*

All binders have the following methods attached to it:

   :func:`.find` find all objects matching the criteria (see <link>)
   :func:`get` / :func:`safe_get` for getting a single object matching a certain criteria 
   :func:`choose` for choosing a random objects which matches the criteria 
   :func:`count` for counting amount of objects matching the criteria  
   :func:`create` for counting amount of objects matching the criteria  

User Objects (or MutableObjects)
--------------------------------

User objects are mutable objects which can be created/delete/updated by the user. A user-object has a unique identifier *id*, which is unique among all user-object types.  
The collection itself may change over time and therefore the objects are not cached. 
Query methods like :func:`.find` may return a new instance representing the same object:

User-objects are grouped by types and are accessed via *system.objects.TypeName*:

.. code-block:: python

    system.objects.Filesystem.find()
       
The user-object classmethod :func:`.create` is binded to system using the object type binder:

.. code-block:: python

    system.objects.Filesystem.create()

MutableObjects Definitions
~~~~~~~~~~~~~~~~~~~~~~~~~~

All System user-objects are derived from :class:`The User Object<.MutableObjects>` class. 
It may also override the *_BINDER_CLASS* and *_BOUNDED_METHODS* 
The default *_BINDER_CLASS* is :class:`MutableObjectsBinder>`. 

Additional type specific collection methods should be added the the binder, and not to the object class. 
For example:

.. code-block:: python

  >>> from infinipy2.core import MutableObjects, MutableObjectsBinder

  >>> class User(MutableObjects):
  ...     FIELDS = []
  ...     _BINDER_CLASS=UserBinder
 
  >>> class UserBinder(GenericComponentBinder):
  ...     def get_infinidat_users(self):
  ...         return self.find(role='INFINIDAT')
  

Updates and deletion
~~~~~~~~~~~~~~~~~~~~

see <link to system object update/delete methods>

Events
------

Events are defined as a Read-only collections. An event cannot be changed once it was created, 
but unlike components, the collections itself changes as more events are added.

It is possible for a user to create a custom event.
Such creation is different than the user-object creation since events are constantly generated by system and is not controlled by the user.
This event is treated as any other event, and cannot be modified/deleted later        

Events Queries
~~~~~~~~~~~~~~

The main method for dealing with events is :func:`.find` which allow user to filter and sort events.
Events are identified by a unique *id* and *uuid*. and like user-objects are not cached.   


.. code-block:: python

    event = system.events.find(Event.fields.code='FILESYSTEM_CREATE') # get 'FILESYSTEM_CREATE' events


.TODO : which fields to fetch? 

Events Object
~~~~~~~~~~~~~

Event object is defined in :class:`Event` and is is derived from :class:`ReadOnlyObject`. 
The collection is attached to the system via :class:`EventTypeBinder>`:

.. code-block:: python

    event = system.events.find(Event.filed.code='FILESYSTEM_CREATE') # get 'FILESYSTEM_CREATE' events
    event = system.events.get_last_events(num=100)


Getting Event Attributes
~~~~~~~~~~~~~~~~~~~~~~~~

The methods :func:`.get_filed` :func:`.get_fields` uses the cached data by defaults, to allow fast iteration on fetched objects
 

Components
----------

All system components are represented by a fixed collections objects, grouped by component type. 
These objects are created and cached during system initialization the :class:`ComponentTypeBinder>`. 
Query methods like :func:`.find` will always return the same instance for a a specific component.
Components cannot be created, deleted or updated. Some components may support state modifying operations    

.. note:: The component *object* itself is cached. Actual data of this object is usually not cached.

Retrieving Component Objects
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Components collections are accessed using system.components.TypeName.
Getting component object(s) of a certain type is done using the :func:`.find` (see <link to system object find/queries > 
In addition it is possible to get a specific component using :func:`.get`, :func:`.safe_get` and :func:`.choose` 
    
.. code-block:: python

    drives = system.components.Drive.find(Drive.fields.status!='OK') # get all drives in system with a matching criteria
    drives = system.components.Drive.get_all() # get all drives in system (no interaction with system)
    drives = system.components.Drive.find(Drive.fields.status=='OK') # filter drives by status 
    drives = system.components.Drive.get(id=...) # get a specific drive by id  
    drives = system.components.Drive.choose() # get a random drive with match the criteria

The method :func:`.find` always generates a system API query and refreshes object information, thus allowing usage of cached data. for example:

.. code-block:: python

    # get all running drives
    >>> drives =[drive for drive in system.comoponents.Drive.find().only_fields(["data"]) if drive.get_field("data", cached=True)['state'] == 'OK']
    
The method :func:`.get_all` returns all objects from cache without interacting with the system     


Component Objects
~~~~~~~~~~~~~~~~~

All System components are derived from :class:`GenericSystemComponent<.GenericSystemComponent>` class. And should define a *_TYPE_NAME*. This is the type name as defined in the system.
It may also override the *_BINDER_CLASS* and *_BOUNDED_METHODS* 
*_BINDER_CLASS* should derive from :class:`ComponentTypeBinder>`

.. code-block:: python

  >>> from infinipy2.core import GenericSystemComponent, GenericComponentBinder

  >>> class Node(GenericSystemComponent):
  ...     FIELDS = []
  ...     _TYPE_NAME='node'
  ...     _BINDER_CLASS=NodeBinder
  ...     def is_master(self):
  ...         return node.get_index() = 1       
 
  >>> class NodeBinder(GenericComponentBinder):
  ...     def get_master_node(self):
  ...         for node in self.get_all():
  ...            if node.is_master():
  ...                return node

Components Container
~~~~~~~~~~~~~~~~~~~~

Component type binders are attached to :class:`.ComponentBinderContainer` using :func:`.install` 
In addition the container will have additional shortcut methods for interacting with the entire components collection  

.. code-block:: python

    all_components = system.components.get_all() # get all components of all types
    specific_component = system.components.get_by_id() # get a specific component by id

Component hierarchy:
~~~~~~~~~~~~~~~~~~~~

System's components are arranged in an hierarchal structure, where :class:`The System Component<.SystemComponent>` is the root and represents the physical system
Each component is identified by *id*, *type*, *parent_id*, and *index*. 
While *id* is an unique identifier, *index* represents the physical location of a sub-component in relation to it's parent. 
Therefore components of the same type may have the same index (e.g. enclosure drives)

Component will expose the :func:`.get_parent` and :func:`.get_sub_components`:

.. code-block:: python

    drive.get_parent() # ==> enclosure object
    enclosure.get_sub_components() # ==> list of drives belonging to this enclosure   

.. note:: The list of sub components may be contain more than one type of components                
.. note:: Using the above methods does not require any interaction with the system and are much faster than using find  

Status and Alerts
~~~~~~~~~~~~~~~~~

Component expose :func:`.get_fields` and :func:`.get_field` as described in <link to system object>  
In addition all components types will expose :func:`.get_status`, :func:`.get_alerts`, :func:`.get_data`

.. code-block:: python
   
   drive.get_alerts() # ==> list of alerts
   drive.get_status() # ==> component status (not state)
   drive.get_data() # ==> Additional component type specific data  

Some component types have states (not to be confused with status, which is an aggregation of alerts). 
These components types will have the additional :func:`.get_state` and possibly a state modifying methods

Installing Components
~~~~~~~~~~~~~~~~~~~~~

All components in the system are installed at system creation.
Component types without pre-defined class are dynamically added based component type list, using the :class:`.GenericSystemComponent`
 
